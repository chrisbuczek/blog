# How JWT Works

Short explanation of how Json Web Token works using Node.js with jsonwebtoken library and React.js.

## The Basics

JWT's purpose is to securely transmit information between parties as json objects. JWT's are structed from three parts:

1. Header
2. Payload
3. Signature

Each part is encoded in Base64 and separated by a period. Header contains algorythm used for token sign encryption (ex. "alg": "HS256") and token type (ex. "typ": "JWT").
Payload is where we store our claims. Most often it contains user name, user email or id, user roles, token expiration. Payload can be encrypted, but
most implementations only use signed, not encrypted tokens. This means that the data in the payload can be read by a 3rd party if intercepted. **Sensitive information
should never travel in a JWT payload.**

## Generating the token

```js filename="tokenGenerate.ts" copy
import jwt from "jsonwebtoken";

const generateToken = (id: string) => {
  return jwt.sign({ id }, process.env.JWT_SECRET_KEY as string, { expiresIn: "30d" });
};

export default generateToken;
```

## Authorization middleware

```js filename="middleware/auth.ts" copy
import jwt from "jsonwebtoken";
import type { Request, Response, NextFunction } from "express";
import type { IUser } from "../types/User.js";
import User from "../models/User.js";

interface AuthRequest extends Request {
  user?: IUser;
}

interface JWTPayload extends jwt.JwtPayload {
  id: string;
}

const auth = async (req: AuthRequest, res: Response, next: NextFunction) => {
  let token;

  if (req.headers.authorization && req.headers.authorization.startsWith("Bearer")) {
    try {
      token = req.headers.authorization.split(" ")[1];
      if (!token) {
        return res.status(401).json({ message: "No authorization token found in request" });
      }

      const secret = process.env.JWT_SECRET_KEY;
      if (!secret) {
        return res.status(500).json({ message: "Server configuration error" });
      }

      const decodedToken = jwt.verify(token, secret) as unknown as JWTPayload;

      const user = await User.findById(decodedToken.id).select("-passwordHash");

      if (!user) {
        return res.status(401).json({ message: "User not found" });
      }

      req.user = user;

      next();
    } catch (error) {
      if (error instanceof jwt.TokenExpiredError) {
        return res.status(401).json({ message: "Token expired" });
      } else if (error instanceof jwt.JsonWebTokenError) {
        return res.status(401).json({ message: "Invalid token" });
      } else {
        return res.status(401).json({ message: "Authentication failed" });
      }
    }
  } else {
    res.status(401).json({ message: "Not authorized, no token" });
  }
};

export default auth;
```

## Sending the token to the client

```js filename="routes/User.ts" {11} copy
router.post("/login", async (req, res) => {

  const { email, password } = req.body;
  const foundUser = await User.findOne({ email });

  if (foundUser && (await foundUser.matchPassword(password))) {
    res.json({
      name: foundUser.name,
      email: foundUser.email,
      roles: foundUser.roles,
      token: generateToken(foundUser._id as string),
    });
  } else {
    res.status(401);
    throw new Error("Invalid Email or Password");
  }
});
```

## Saving the token in the client

```js filename="routes/User.ts" {11} copy
router.post("/login", async (req, res) => {

  const { email, password } = req.body;
  const foundUser = await User.findOne({ email });

  if (foundUser && (await foundUser.matchPassword(password))) {
    res.json({
      name: foundUser.name,
      email: foundUser.email,
      roles: foundUser.roles,
      token: generateToken(foundUser._id as string),
    });
  } else {
    res.status(401);
    throw new Error("Invalid Email or Password");
  }
});
```
