# How JWT Works

Short explanation of how Json Web Token works using Node.js with jsonwebtoken library and React.js.

## The Basics

JWT's purpose is to securely transmit information between parties as json objects. JWT's are structed from three parts:

1. Header
2. Payload
3. Signature

Each part is encoded in Base64 and separated by a period. Header contains algorythm used for token sign encryption (ex. "alg": "HS256") and token type (ex. "typ": "JWT").
Payload is where we store our claims. Most often it contains user name, user email or id, user roles, token expiration. Payload can be encrypted, but
most implementations only use signed, not encrypted tokens. This means that the data in the payload can be read by a 3rd party if intercepted. **Sensitive information
should never travel in a JWT payload** (unless it's encrypted). Signature

## Generating/signing the token

There are two ways of signing a token: with a symetric key or with an asymetric key.

```js filename="tokenGenerate.ts" copy
import jwt from "jsonwebtoken";

const generateToken = (id: string) => {
  if (!process.env.JWT_SECRET_KEY) {
    throw new Error("JWT_SECRET_KEY environment variable is required");
  }

  return jwt.sign({ id }, process.env.JWT_SECRET_KEY as string, { expiresIn: "1h" });
};

export default generateToken;
```

## Sending the token to the client

Before sending the token to the client we have to authenticate him first. Usually we use '/login' route for that.
After ensuring that the provided email and password by the client match stored data in the database, we generate and send him a valid token.
In the code example we only put user id in the payload. We could also put name, email and roles inside the token payload.

```js filename="routes/User.ts" {11} copy
router.post("/login", validate(loginSchema), async (req, res) => {

  const { email, password } = req.body;
  const foundUser = await User.findOne({ email });

  if (foundUser && (await foundUser.matchPassword(password))) {
    res.json({
      name: foundUser.name,
      email: foundUser.email,
      roles: foundUser.roles,
      token: generateToken(foundUser._id as string),
    });
  } else {
    res.status(401);
    throw new Error("Invalid Email or Password");
  }
});
```

## Authorization middleware

```js filename="middleware/auth.ts" copy
import jwt from "jsonwebtoken";
import type { Request, Response, NextFunction } from "express";
import type { IUser } from "../types/User.js";
import User from "../models/User.js";

interface AuthRequest extends Request {
  user?: IUser;
}

interface JWTPayload extends jwt.JwtPayload {
  id: string;
}

const auth = async (req: AuthRequest, res: Response, next: NextFunction) => {
  let token;

  if (req.headers.authorization && req.headers.authorization.startsWith("Bearer")) {
    try {
      token = req.headers.authorization.split(" ")[1];
      if (!token) {
        return res.status(401).json({ message: "No authorization token found in request" });
      }

      const secret = process.env.JWT_SECRET_KEY;
      if (!secret) {
        return res.status(500).json({ message: "Server configuration error" });
      }

      const decodedToken = jwt.verify(token, secret) as unknown as JWTPayload;

      const user = await User.findById(decodedToken.id).select("-passwordHash");

      if (!user) {
        return res.status(401).json({ message: "User not found" });
      }

      req.user = user;

      next();
    } catch (error) {
      if (error instanceof jwt.TokenExpiredError) {
        return res.status(401).json({ message: "Token expired" });
      } else if (error instanceof jwt.JsonWebTokenError) {
        return res.status(401).json({ message: "Invalid token" });
      } else {
        return res.status(401).json({ message: "Authentication failed" });
      }
    }
  } else {
    res.status(401).json({ message: "Not authorized, no token" });
  }
};

export default auth;
```

## Saving the token in the client

```js filename="routes/User.ts" {11} copy
router.post("/login", async (req, res) => {

  const { email, password } = req.body;
  const foundUser = await User.findOne({ email });

  if (foundUser && (await foundUser.matchPassword(password))) {
    res.json({
      name: foundUser.name,
      email: foundUser.email,
      roles: foundUser.roles,
      token: generateToken(foundUser._id as string),
    });
  } else {
    res.status(401);
    throw new Error("Invalid Email or Password");
  }
});
```
